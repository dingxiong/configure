<!DOCTYPE html>
<html>
  <head>
    <title>Computer Configuration</title>
  </head>

  <body>
    
    <h1> Emacs configuration </h1>
    My experience is only limited to emacs24 or above. Since 
    emacs24 takes package.el with itself, that is why I choose
    it instead of previous editions.
    <dl>
      <dt><b style="background-color:red">
	  Set the <i>elpa</i> resource websites
      </b></dt>
      <dd> 
	choose all of these three : <br>
	<code><pre style="color:green">
	    ;; set the package connection websites
	    (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
	    ("marmalade" . "https://marmalade-repo.org/packages/")
	    ("melpa" . "http://melpa.org/packages/")))
	</pre><code>
      </dd>
     
      <dt><b style="background-color:red">
	  Set <i>mode</i> search directories
      </b></dt>
      <dd> 
	Set one folder and all its subfolders. <br>
	<code><pre style="color:green">
	    ;; set the package search path
	    (let ((default-directory "~/.emacs.d/elpa/"))
	    (normal-top-level-add-subdirs-to-load-path ))
	</pre><code>
      </dd>

      <dt><b style="background-color:red">
	  Force emacs to read PATH variable
      </b></dt>
      <dd>
	It took me a lot of time to figure it out. Finally, I installed
	<i>exec-path-from-shell</i>. <br>
	<code><pre style="color:green">
	    ;; force GUI to read $PATH
	    (require 'exec-path-from-shell)
	    (exec-path-from-shell-copy-env "PATH")
	</pre></code>
      </dd>

      <dt><b style="background-color:red">
	  Aesthetic part
      </b></dt>
      <dd>
	<code><pre style="color:green">
	    ;; some simple configuration
	    (setq inhibit-startup-message t) ;;forbid welcome screen 
	    (tool-bar-mode -1) ;; forbid too bar
	    (require 'color-theme) ;; set up color theme
	    (color-theme-initialize) 
	    (color-theme-deep-blue) 
	    (setq line-number-mode t) ;; set row number
	    (setq column-number-mode t) ;; enable column number
	    (add-to-list 'default-frame-alist 
	    '(font . "Monospace-13")) ;; set the default font

	    ;; enable copy/paste from/to emacs
	    (setq x-select-enable-clipboard t)	    
	</pre></code>
      </dd>
    </dl>
    
    The above is the first part of this configuration. Now we need
    to set the configuration for each individual file format.
    <dl>
      <dt><b style="background-color:blue">
	  Yasnippet : the god 
      </b></dt>
      <dd>
	<code><pre style="color:green">
	    ;; add yasnippet
	    (require 'yasnippet)
	    (yas-global-mode -1)
	</pre></code>
      </dd>

      <dt><b style="background-color:blue">
	  auto-complete 
      </b></dt>
      <dd>
	<code><pre style="color:green">
	    ;; set up auto-complete
	    (require 'auto-complete)
	    (require 'auto-complete-config)
	    (add-to-list 'ac-dictionary-directories "~/.emacs.d/ac-dict")
	    (ac-config-default)
	</pre></code>
      </dd>
      
      <dt><b style="background-color:blue">
	  Python
      </b></dt>
      <dd>
	Python environment setup is a little complicated.<br>
	First, install python-mode.<br>
	Then, install jedi.el for code completion. Note,
	jedi require a lot of prerequisite packages and
	it should be able to load these exec tools.
	<code><pre style="color:green">
	    ;; set up Python Envirenment
	    (require 'ipython)
	    (autoload 'python-mode "python-mode" "Python Mode." t)
	    (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
	    (add-to-list 'interpreter-mode-alist '("python" . python-mode))
	    ;; use jedi auto completion
	    (add-hook 'python-mode-hook 'jedi:setup)
	    (setq jedi:complete-on-dot t)
	</pre></code>
      </dd>
    </dl>

    <h1> C/C++ related </h1>
    <h3> General rules/procedure</h3>
    <ol>
      <li>Good book : C++ primer; effective C++. </li>
      <li>Good editor : Emacs </li>
      <li>Debug tool : <br><br>
	<i>Valgrind</i> : mainly used for memory fault debugging, which is 
	the first step. Whenever you encounter segmentation fault,
	you probably should consider using it. <br>
	PS: recently, fftw3 tortured me a lot, there are a few pieces of 
	heap memory needed be freed by fftw_cleanup(). I was not 
	aware of this at the beginning. <br>
	PSS: for pthread multi-thread programs, helgrind helps a lot.
	<code>
	  valgrind --tool=helgrind ./a.out
	</code>
	<br><br>
	<i>gdb</i>: not need to say much about this famous tool. It helps
	you track each step in your code. If necessary, writing a
	script will save a lot of time.<br><br>
      </li>
      <li>Profile tool : locate the Achilles heel of your
	program => try to find ways to make it faster.
	Of cause, the best way is to produce a performance diagram,
	which utilizes <i style="color:red" >gprof2dot</i> 
	and <i style="color:red">dot</i>. <br>
	<code style="color:green">
	  gprof path/to/your/executable | python gprof2dot.py 
	  | dot -Tpng -o output.png
	</code><br>
	BE CAREFUL : compiler flag <i style="color:red">-pg</i> will
	result memory leak.
      </li>
      <li>
	binding tool : for many scientific programs, it is 
	necessary to import C++ to python/Matlab ( actually,
	python+numpy is the trend ). Therefore, there is a
	necessity to know something about binding. <br>
	<b>Matlab</b>: it uses Mex files. Although it claims support
	for C++, but from the examples it provides, it just transfer
	C++ classes to C functions and wrap C functions instead.	
	<br>
	<b>Python</b>: I tried <i style="color:red">Ctypes</i>, 
	it is not convenient. Also, 
	it only supports C interface. Then I tried 
	<i style="color:red">Boost.Python</i>. Though the initial
	learning curves is slow, the effort pays eventually.	
      </li>
    </ol>

    <h3> Specific skills</h3>
    
    <ol>
      <li><p>
	  <b>Selective compilation</b>: &nbsp&nbsp&nbsp&nbsp
	  /*...*/ can only be used to comment out a block if there is
	  no /**/ inside. So in order to compile selectively, you 
	  basically have 2 choices. First, use 
	  <i style="color:green">#if 0 ... #endif</i>. The second
	  is to use <i style="color:green"> switch case </i>, and
	  put the case blocks inside curly bracket.
      </p></li>

      <li><p>
	  <b> processor time measure</b>: &nbsp&nbsp&nbsp&nbsp
	  <code style="color:green"> clock_t clock(void); </code>
	  returns the processor time consumed by the program. The
	  value returned is expressed in clock ticks. <br>
	  The counterpart in Python is 
	  <code style="color:green"> time.clock()</code>, but the
	  unit is different.
      </p></li>

    </ol>

  </body>
</html>
